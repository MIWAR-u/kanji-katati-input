<body>
<div class="container">
<h1>漢字かたちサーチ</h1>
<div id="status" class="status">TTLファイルを読み込み中...</div>

<div class="info">
検索方法: 複数の形を検索する場合は、スペースで区切ってください<br>
例: 「目 ル」「一 日 ル」「はらい」「みみ」「四角」「フ フ はらい」
</div>

<div class="search-container">
<input type="text" id="searchInput" placeholder="例：目 ル、一 日 ル、はらい、みみ、四角、にんべん" disabled>
</div>

<div id="results"></div>
</div>

<script>
let kanjiData = [];
let resourceMap = {};
let termToUriMap = {};

const queryInput = document.getElementById('searchInput');
const resultsDiv = document.getElementById('results');
const statusDiv = document.getElementById('status');

window.onload = async () => {
    try {
        const response = await fetch('Kanji_katati_lod.ttl');
        const text = await response.text();
        parseTTL(text);
        statusDiv.innerText = `✓ 読込完了: ${kanjiData.length}件をロードしました`;
        statusDiv.style.background = "#d4edda";
        queryInput.disabled = false;
        queryInput.focus();
    } catch (err) {
        statusDiv.innerText = `❌ Kanji_katati_lod.ttl が見つかりません。`;
        statusDiv.style.background = "#f8d7da";
    }
};

function parseTTL(text) {
    kanjiData = []; resourceMap = {}; termToUriMap = {};
    const blocks = text.split(/\s\.\s*\n/).filter(b => b.trim());
    blocks.forEach(block => {
        const lines = block.trim().split('\n');
        const subject = lines[0].match(/<([^>]+)>/)?.[1];
        if (!subject) return;

        const data = { uri: subject, tsukuri: "", daihyo: "", namae: [], yomi: [], groups: [], alts: [] };
        lines.forEach(line => {
            const val = line.match(/"([^"]+)"/)?.[1];
            if (line.includes('prop:つくり')) data.tsukuri = val;
            if (line.includes('prop:代表値')) data.daihyo = val;
            if (line.includes('prop:なまえ')) data.namae.push(val);
            if (line.includes('prop:よみ')) data.yomi.push(val);
            if (line.includes('prop:別の言い方')) data.alts.push(val);
            if (line.includes('prop:かたち')) {
                const m = line.match(/rdf:value\s*([^\]]+)/);
                if (m) data.groups.push(m[1].split(',').map(u => u.trim()));
            }
        });

        const shortId = (subject.includes('katati_dic') ? 'dic:' : 'res:') + subject.split('/').pop().replace('+', '');
        resourceMap[subject] = data;
        resourceMap[shortId] = data;

        const terms = [data.tsukuri, data.daihyo, ...data.namae, ...data.yomi, ...data.alts];
        terms.forEach(t => {
            if (!t) return;
            if (!termToUriMap[t]) termToUriMap[t] = new Set();
            termToUriMap[t].add(subject);
            termToUriMap[t].add(shortId);
        });

        kanjiData.push(data);
    });
}

function unicodeToChar(uStr) {
    const hex = uStr.replace(/dic:|res:|U|\+/g, '');
    try {
        const cp = parseInt(hex, 16);
        if (isNaN(cp)) return null;
        return String.fromCodePoint(cp);
    } catch { return null; }
}

function getDisplayChar(uri) {
    const res = resourceMap[uri];
    if (res) return res.tsukuri || res.daihyo;
    return unicodeToChar(uri) || uri;
}

function getQueryUriSet(input) {
    let s = termToUriMap[input] || new Set();
    s.add(`res:${input}`);
    s.add(`dic:${input}`);
    return s;
}

function containsInHierarchy(uri, queryUriSet, visited = new Set()) {
    if (visited.has(uri)) return false;
    visited.add(uri);
    if (queryUriSet.has(uri)) return true;
    const res = resourceMap[uri];
    if (!res) return false;
    for (let g of res.groups) {
        for (let c of g) {
            if (containsInHierarchy(c, queryUriSet, visited)) return true;
        }
    }
    return false;
}

// URIを展開して全ての子要素を取得（1階層のみ）
function expandUri(uri) {
    const res = resourceMap[uri];
    if (!res || res.groups.length === 0) {
        return [uri];
    }

    // 最初のグループを展開
    // 複数のグループがある場合は最初のものを使用
    if (res.groups.length > 0 && res.groups[0].length > 0) {
        return res.groups[0];
    }

    return [uri];
}

// グループを完全に展開したリストを取得
function getExpandedGroup(group) {
    let expanded = [];
    for (let uri of group) {
        const children = expandUri(uri);
        expanded.push(...children);
    }
    return expanded;
}

function isShapeNameExactMatch(item, queryPart) {
    if (item.tsukuri === queryPart) return true;
    const resUri = `res:${queryPart}`;
    if (item.uri === resUri) return true;
    return false;
}

queryInput.addEventListener('input', () => {
    const query = queryInput.value.trim();
    if (!query) { resultsDiv.innerHTML = ''; return; }

    const parts = query.split(/[\s　]+/).filter(Boolean);
    const queryUriSets = parts.map(p => getQueryUriSet(p));

    const results = kanjiData.map(item => {
        let score = 0;
        let matchedGroupIdx = -1;
        let matchedUris = new Set();
        let matchType = '';

        if (parts.length === 1 && isShapeNameExactMatch(item, parts[0])) {
            score = 1300;
            matchType = 'shape-exact';
        } else if (item.namae.includes(query) || item.tsukuri === query) {
            score = 1000;
            matchType = 'name-exact';
        } else {
            item.groups.forEach((group, gIdx) => {
                let currentMatchedUris = new Set();
                let coveredParts = new Set();

                group.forEach(gUri => {
                    queryUriSets.forEach((set, pIdx) => {
                        if (containsInHierarchy(gUri, set)) {
                            coveredParts.add(pIdx);
                            currentMatchedUris.add(gUri);
                        }
                    });
                });

                if (coveredParts.size === queryUriSets.length) {
                    // 通常の完全一致判定
                    let queryPartsRemaining = [...Array(parts.length).keys()];
                    let groupUrisRemaining = [...group];
                    let isStrictPerfect = true;

                    for (let partIdx of queryPartsRemaining) {
                        let found = false;
                        for (let i = 0; i < groupUrisRemaining.length; i++) {
                            const gUri = groupUrisRemaining[i];
                            if (containsInHierarchy(gUri, queryUriSets[partIdx])) {
                                groupUrisRemaining.splice(i, 1);
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            isStrictPerfect = false;
                            break;
                        }
                    }

                    isStrictPerfect = isStrictPerfect && groupUrisRemaining.length === 0;

                    // 展開した完全一致判定
                    if (!isStrictPerfect) {
                        const expandedGroup = getExpandedGroup(group);
                        let expandedQueryPartsRemaining = [...Array(parts.length).keys()];
                        let expandedGroupUrisRemaining = [...expandedGroup];
                        let isExpandedPerfect = true;

                        for (let partIdx of expandedQueryPartsRemaining) {
                            let found = false;
                            for (let i = 0; i < expandedGroupUrisRemaining.length; i++) {
                                const gUri = expandedGroupUrisRemaining[i];
                                if (containsInHierarchy(gUri, queryUriSets[partIdx])) {
                                    expandedGroupUrisRemaining.splice(i, 1);
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                isExpandedPerfect = false;
                                break;
                            }
                        }

                        isExpandedPerfect = isExpandedPerfect && expandedGroupUrisRemaining.length === 0;

                        if (isExpandedPerfect) {
                            isStrictPerfect = true;
                        }
                    }

                    if (isStrictPerfect && score < 1200) {
                        score = 1200;
                        matchedGroupIdx = gIdx;
                        matchedUris = currentMatchedUris;
                        matchType = 'perfect';
                    } else if (score < 800) {
                        score = 800;
                        matchedGroupIdx = gIdx;
                        matchedUris = currentMatchedUris;
                        matchType = 'partial';
                    }
                }
            });
        }

        if (score === 0 && item.yomi.includes(query)) {
            score = 700;
            matchType = 'yomi';
        }

        return { item, score, matchedGroupIdx, matchedUris, matchType };
    }).filter(r => r.score > 0).sort((a, b) => b.score - a.score);

    console.log(`Query: "${query}" - Found ${results.length} results`);
    if (results.length > 0) {
        console.log(`Top result: ${results[0].item.tsukuri}, score: ${results[0].score}, type: ${results[0].matchType}`);
    }

    resultsDiv.innerHTML = results.map(r => {
        let badge = "";
        let itemClass = "";

        if (r.matchType === 'shape-exact') {
            badge = '<span class="badge badge-shape-exact">形状名一致</span>';
            itemClass = "shape-exact";
        } else if (r.matchType === 'perfect') {
            badge = '<span class="badge badge-perfect">完全構成一致</span>';
            itemClass = "perfect-hit";
        } else if (r.matchType === 'name-exact') {
            badge = '<span class="badge badge-direct">なまえ一致</span>';
            itemClass = "direct-hit";
        }

        let h = `<div class="result-item ${itemClass}">`;
        h += `<div class="kanji-display">${r.item.tsukuri || r.item.daihyo || '?'}${badge}</div>`;
        h += `<div class="name-display">${r.item.namae.join(' / ')}</div>`;
        r.item.groups.forEach((g, i) => {
            h += `<div class="shape-display">`
            g.forEach(u => {
                const isM = (i === r.matchedGroupIdx && r.matchedUris.has(u));
                const isS = !unicodeToChar(u);
                h += `<span class="shape-item ${isM ? 'matched' : ''} ${isS ? 'special' : ''}">${getDisplayChar(u)}</span>`;
            });
            h += `</div>`;
        });
        return h + `</div>`;
    }).join('');
});
</script>
</body>
</html>
